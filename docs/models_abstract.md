Абстрактные модели
==================

Класс `Model` и функция `upgrade` превращают массив в объект `ArrayObject`.

Класс `Model` предназначен для обозначения разного рода данных, не привязанных к таблице в базе данных (некая абстрактаная сферическая модель в вакууме).

Он может решать, например, следующую задачу:

Допустим, при помощи сложных (или не очень) запросов был получен массив данных (массив ассоциативных массивов) следующего типа:

	$myarr = array(
		array('title'=>'Подшипник', 'color'=>'Металлик', 'catalog_id'=>17),
		array('title'=>'Болт 28мм',  'catalog_id'=>18),
		array('title'=>'Гайка металлическая',  'catalog_id'=>18),
		array('title'=>'Соединитель', 'color'=>'Синий', 'catalog_id'=>35),
		array('title'=>'Крышечка пластмассовая', 'color'=>'Красный', 'catalog_id'=>7)
	);

Это вполне может быть корзина товаров в интернет-магазине, которая хранится в `$_SESSION`.

Его хочется вывести в `foreach`. Но при этом написать поменьше кода, вывести каталог по его идентификатору и т.д. В случае с ActiveRecord всё просто - массив является одновременно и объектом (ArrayObject), что позволяет магически запрашивать другие таблицы, переопределять свойства и т.д.

Класс `Model` выполяет эту задачу - делает из массива объект.

Например, для предыдущего случая, мы можем сделать так:

	d()->products = d()->Model($myarr);

И вывести в шаблоне следующий код:

	<foreach products>
		<div>
			<b>Название:<b> {.title}, <b>Раздел каталога:</b> {this.catalog.title}
		</div>
	</foreach>

`{this.catalog.title}` обратится к каталогу автоматически также, как это делает ActiveRecord.

Альтернативный способ определить объект следующий:

	d()->products = upgrade($myarr);

Допустим, мы хотим переопределить поле `color`. Для это мы создаём класс, допустим, `Basketproduct`:

	<?php
	class Basketproduct extends Model
	{		
		function color()
		{
			if($this->get('title')==''){
				return 'Цвет не задан';
			}
			return $this->get('color');
		}
	}

И в нужном месте контроллера просто пишем:

	d()->products = d()->Basketproduct($myarr);

Сам класс `Model` не обращается к базе данных, однако он наследуется от оригинального `ActiveRecord`. Поэтому он имеет
такой метод, как `to_array`, преобразующий объект обратно в массив.

То же самое касается остальных методов, например, `d()->products->sort_by('title');` позволит отсортировать данные по алфавиту.

### Использование класса Model

Вот примеры использования:

* Вывод в шаблоне обычного массива данных с использованием foreach
* Переопределение поля массива в виде функции (как это используется в ActiveRecord)
* Преобразовать корзину (которая хранится в `$_SESSION`) в массив-объект со связанными товарами.
* Научить массив сортировать и обрабатывать сам себя (например, массив городов, отдающий 10 самых популярных городов).
* Использовать в качестве источника данных XML, JSON, текстовые списки, Excel-файлы и т.д.
* Спрятать из шаблона код в модель.
* Склеить массивы из двух таблиц (фотографии и видео) в новый объект со всеми данными.
* Превратить полученные из таблицы данные в массив, отсортировать его специальными функциями работы с массивами (например, underscore или array_map), а затем превратить обратно в объект. 
